# Vercel + Supabase + React(Next.js) + Python(FastAPI) 오케스트레이터 구현 가이드

본 문서는 현재 보유하신 Python 백엔드 구조를 유지하면서,
- **프론트엔드: React 기반(권장: Next.js)**
- **배포: Vercel**
- **백엔드 실행: Vercel Functions (Python Runtime)**
- **DB/인증/스토리지: Supabase**
로 운영 가능한 형태로 정리한 구현 계획서입니다.

---

## 1) 권장 아키텍처(운영 관점 “가장 단순”)

### 선택지 A (권장): **단일 Vercel 프로젝트**
- **Next.js(React)**: UI/라우팅/정적 리소스
- **Python FastAPI**: Vercel의 **Python Runtime Functions**로 `/api/*` 하위에서 동작
- 장점: 도메인 1개, CORS/쿠키/세션 처리 단순, 배포 파이프라인 1개
- 전제: 프론트는 JS/TS(Next.js), 백엔드는 Python으로 분리 운영

Vercel은 Python Runtime에서 **FastAPI/Flask 등을 지원**하며, **Python 3.12 고정**이고 변경 불가입니다. :contentReference[oaicite:0]{index=0}  
또한 Python Runtime에서도 **스트리밍 응답**을 지원합니다. :contentReference[oaicite:1]{index=1}

### 선택지 B: **Vercel 프로젝트 2개(프론트/백 분리)**
- 프론트(Next.js) / 백(FastAPI) 각각 별도 프로젝트
- 장점: 배포/스케일/권한 분리
- 단점: CORS/도메인 분리/인증 연동이 더 번거로움

본 문서는 **선택지 A(단일 프로젝트)** 기준으로 작성합니다.

---

## 2) 프로젝트 구조(권장 리팩토링)

현재 구조:
/backend (FastAPI)
/frontend (React 자바스크립트 파일)

scss
코드 복사

권장 구조(단일 Vercel 프로젝트 기준):
orchestrator/
├── app/ # Next.js App Router (React UI)
├── public/
├── api/ # ⭐ Vercel Python Functions 엔트리
│ ├── index.py # ⭐ FastAPI app 노출(필수)
│ ├── events.py # (선택) SSE 전용 엔드포인트
│ └── ... # 필요 시 추가
├── backend/ # 기존 Python 패키지(로직 유지)
│ ├── main.py
│ ├── config.py
│ ├── agents/
│ ├── orchestrator/
│ ├── models/
│ ├── storage/
│ └── prompts/
├── requirements.txt # ⭐ Python deps (Vercel이 인식)
├── package.json # Next.js deps
├── next.config.js
└── vercel.json # (선택) functions 설정/라우팅/번들 제외

yaml
코드 복사

Vercel의 “Python Runtime + Next.js 혼합”은 **/api 경로로 Python 백엔드를 붙이는 형태**가 대표 패턴입니다. :contentReference[oaicite:2]{index=2}  
또한 Python Runtime 문서에서 `api/index.py` 형태의 엔트리 구성을 명시합니다. :contentReference[oaicite:3]{index=3}

---

## 3) FastAPI를 Vercel Python Function으로 올리는 방식

### 3.1 핵심 원칙
- Vercel이 인식하는 Python Function 엔트리는 보통 **`/api/*.py`** 입니다.
- **`api/index.py`에서 FastAPI `app` 객체를 노출**시키는 방식으로 단일 앱을 구성하는 것이 가장 단순합니다. :contentReference[oaicite:4]{index=4}
- FastAPI는 Vercel에서 “단일 Vercel Function” 형태로 동작하며, 번들 사이즈 제한(250MB 등)도 유의해야 합니다. :contentReference[oaicite:5]{index=5}

### 3.2 `api/index.py` 연결(개념 예시)
- `backend/main.py`의 FastAPI 인스턴스를 그대로 가져와 노출합니다.
- (중요) 상대경로 파일 접근은 “프로젝트 루트”가 기준일 수 있으니 경로 처리 규칙을 고정합니다. :contentReference[oaicite:6]{index=6}

---

## 4) Supabase 적용(권장: DB + Auth + RLS)

### 4.1 왜 Supabase가 적합한가
- 세션/메시지/케이스파일/최종리포트를 **구조화 저장**하기 쉽고,
- Auth를 붙이면 병원/법률 등 카테고리별 접근통제도 설계 가능합니다.

### 4.2 테이블 권장안(최소)
- `sessions`
  - `id (uuid)`, `user_id`, `category`, `status`, `round_index`, `phase`, `created_at`
- `messages`
  - `id`, `session_id`, `role(user/agent1/agent2/agent3)`, `content_text`, `content_json`, `event_id`, `created_at`
- `case_files`
  - `session_id`, `decisions`, `open_issues`, `assumptions`, `next_experiments`, `summary_text`, `updated_at`
- `final_reports`
  - `session_id`, `report_json`, `report_md(optional)`, `created_at`

### 4.3 RLS(Row Level Security) 권장
- `sessions.user_id = auth.uid()` 기준으로 RLS 구성
- 백엔드에서만 필요한 작업(관리자/서비스 로직)은 **Service Role Key**로 수행(절대 프론트 노출 금지)

### 4.4 프론트에서 Supabase 사용
React(Next.js)에서는 `@supabase/supabase-js`로 쉽게 연동합니다. :contentReference[oaicite:7]{index=7}

---

## 5) Vercel 환경변수 설계(필수)

### 5.1 프론트 공개 변수(반드시 접두사 사용)
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`

### 5.2 서버 전용(절대 프론트로 보내지지 않게)
- `SUPABASE_SERVICE_ROLE_KEY`
- `GEMINI_API_KEY` (또는 사용 중인 LLM 키)
- `INTERNAL_SIGNING_SECRET` (세션 락/서명/웹훅 검증용)

Vercel은 프로젝트 설정/구성 파일로 빌드·라우팅·함수 설정을 제어할 수 있습니다. :contentReference[oaicite:8]{index=8}  
또한 Functions 설정(런타임/메모리/timeout 등)을 구성할 수 있습니다. :contentReference[oaicite:9]{index=9}

---

## 6) SSE(스트리밍) + “2-step(표시용/저장용) 분리” 운영 방식

당초 설계에서 지적하신 대로,
- **UI 노출:** 스트리밍 텍스트(SSE)
- **저장/렌더링:** 턴 종료 후 1회 Non-stream JSON 생성
으로 분리하는 방식이 운영 안정성이 높습니다.

Vercel Python Runtime은 스트리밍 응답을 지원합니다. :contentReference[oaicite:10]{index=10}

### 권장 흐름(1턴)
1) 사용자가 메시지 전송
2) 서버가 SSE로 “읽기 쉬운 텍스트”를 스트리밍
3) 스트림 완료 직후 서버가 Non-stream 호출로 **정합성 있는 JSON**을 생성/저장
4) 프론트는 최종 JSON(또는 요약)을 렌더링/캐시

---

## 7) Next.js(React) 프론트엔드 구성(“JS를 몰라도” 가능한 선택)

### 7.1 결론부터
- **React로 가면 Vercel에서 “Next.js 선택”하면 됩니다.**
- Next.js는 기본 언어가 **JavaScript/TypeScript**입니다.
- “프론트는 JS/TS, 백엔드는 Python” 조합이 일반적이며, Vercel도 이를 전제로 문서를 제공합니다. :contentReference[oaicite:11]{index=11}

### 7.2 JS/TS를 최소화하는 운영 팁
- 프론트 코드는 “화면 + SSE 연결 + 버튼/폼” 정도만 두고
- 핵심 로직(상태머신/라운드/락/케이스파일 업데이트)은 **전부 Python 서버**에 둡니다.
- 타입 안정성이 필요하면 JS 대신 **TypeScript**로 시작하는 편이 유지보수에 유리합니다.

---

## 8) Vercel 배포/로컬 개발 절차(권장)

### 8.1 로컬 개발
- Vercel CLI의 `vercel dev`로 통합 실행 패턴이 공식 템플릿에 존재합니다. :contentReference[oaicite:12]{index=12}
- 로컬에서 Next.js(UI) + Python Function(API)을 함께 확인하기 좋습니다.

### 8.2 배포
- GitHub 연결 → Vercel 자동 배포
- Env Vars 세팅(Production/Preview/Development 별도 세팅 유의)

---

## 9) “Vercel Functions에서 Python 운영” 시 주의점(필수 체크)

1) **Python 버전 고정(3.12)**
   - 런타임 변경 불가. :contentReference[oaicite:13]{index=13}

2) **번들 사이즈(250MB)**
   - 필요 없는 폴더(테스트/데이터)를 제외 설정 권장. :contentReference[oaicite:14]{index=14}

3) **함수 설정(Timeout/Memory)**
   - 장시간 SSE/LLM 호출은 timeout 설정이 중요합니다. :contentReference[oaicite:15]{index=15}

4) **상대경로 파일**
   - Python 함수의 작업 디렉터리가 프로젝트 루트 기준일 수 있으니 경로 규칙 고정. :contentReference[oaicite:16]{index=16}

---

## 10) 구현 체크리스트(이 문서 범위에서 “바로 적용”)

- [ ] Next.js 앱 생성(또는 frontend를 Next.js로 재구성)
- [ ] `/api/index.py`로 FastAPI `app` 노출 (기존 `backend/main.py` 재사용)
- [ ] Supabase 프로젝트 생성 + 테이블/인덱스/RLS 구성
- [ ] Vercel Env Vars 설정(공개/서버 분리)
- [ ] SSE 엔드포인트(`/api/events` 등) + Last-Event-ID 재전송 설계(선택)
- [ ] 2-step(스트리밍 표시 / Non-stream JSON 저장) 적용
- [ ] `vercel.json`로 function timeout/memory + 번들 제외 패턴 구성(필요 시)

---

## 참고(공식/준공식 근거)
- Vercel Python Runtime(버전/스트리밍/번들/엔트리) :contentReference[oaicite:17]{index=17}  
- Vercel FastAPI 배포 개요(단일 Function/제한) :contentReference[oaicite:18]{index=18}  
- Next.js + Python 혼합(아키텍처 패턴) :contentReference[oaicite:19]{index=19}  
- Supabase React Quickstart(프론트 연동) :contentReference[oaicite:20]{index=20}  
- Vercel Functions/Project 설정(운영 설정 포인트) :contentReference[oaicite:21]{index=21}









출처
