# AntiGravity 구현계획: 3 에이전트 토론형 의사결정 시스템 (신규사업/마케팅/개발/영역)
- 문서버전: v1.0
- 목적: 사용자 주제 입력 → Agent1(실행계획) ↔ Agent2(반박) ↔ Agent3(절충) 토론을 **최대 3회 사이클**로 운영하며, 사용자가 “마무리”를 선언하면 즉시 중단 후 **Agent3가 최종 결과물을 별도 페이지로 요약 출력**하는 시스템 구축
- 핵심 UX: 좌측 3D 캐릭터(Agent1/2/3) 애니메이션, 우측 채팅 토론, 최종 결과 페이지(`/final`)

---

## 1) 요구사항 정리 (고정 스펙)

### 1.1 카테고리 (4종 고정)
- 신규사업
- 마케팅
- 개발
- 영역(운영/기타 의사결정 영역)

### 1.2 토론 프로토콜 (라운드당 5턴 고정)
라운드 1회당 내부 토론 턴:
1) Agent1: 구현계획/실행방안(구체)  
2) Agent2: 문제점/반대의견  
3) Agent3: 절충안/개선방향(디테일)  
4) Agent2: 재반박  
5) Agent3: 최종 절충안(라운드 결론)

### 1.3 사이클 제한
- “토탈 3회만” = **토론 사이클(라운드) 최대 3회**
- 각 라운드 종료 후 사용자가 추가 의견을 입력하면 다음 라운드로 진행
- 3회 완료 시 자동으로 최종화(Agent3 Finalizer 호출 → 결과 페이지)

### 1.4 조기 종료(사용자 주도)
사용자가 아래 중 하나를 하면 즉시 종료:
- UI 버튼: `마무리하기`
- 텍스트 트리거: “마무리”, “결론 내자”, “여기서 끝”, “종료”, “최종안”, “정리해줘” 등

조기 종료 시 동작:
- 진행 중인 스트리밍/턴 즉시 중단
- 남은 내부 턴 실행하지 않음
- **Agent3 Finalizer**만 호출하여 최종 결과물 생성
- 결과 페이지로 이동

### 1.5 “논리/추론 요약”은 반드시 채팅에 노출
- 각 에이전트 메시지는 채팅에 표시
- 각 메시지 내에 반드시 “논리 요약(Reasoning Summary)” 섹션 포함(3~6 bullets)

### 1.6 최종 결과물 출력 방식
- 채팅창이 아닌 **별도 결과 페이지**에서 요약 문서 형태로 출력
- 결과 페이지는 “결론 문서” + “실행 체크리스트/로드맵/리스크/지표” 포함

---

## 2) AntiGravity 상 구현 구성(페이지/컴포넌트/서버)

### 2.1 라우팅(권장)
- `/` : 세션 시작(카테고리 선택 + 주제 입력)
- `/session/:id` : 본 토론 화면(좌 3D / 우 채팅)
- `/session/:id/final` : 최종 결과 페이지(Agent3 최종안 렌더)

### 2.2 주요 컴포넌트
- `ScenePanel` (좌측)
  - 3D 캐릭터 3명 표시(Idle 루프)
  - `activeSpeaker` 상태에 따라 speaking 애니메이션/하이라이트 전환
- `ChatPanel` (우측)
  - 메시지 스트리밍 출력
  - 에이전트 배지(Agent1/2/3), 라운드 표시(1/3)
  - `마무리하기` 버튼(상단 고정)
- `FinalReportView` (최종 페이지)
  - 최종안 섹션별 렌더(결론/로드맵/리스크/KPI/오픈이슈)

### 2.3 서버(오케스트레이터) 역할
- 토론 상태 머신 실행(라운드/턴 강제)
- 조기 종료 이벤트 처리
- 메모리/요약(case file) 관리
- 메시지 저장 및 최종 리포트 생성
- 스트리밍(SSE 또는 AntiGravity 제공 스트리밍 인터페이스)으로 UI에 전송

---

## 3) 데이터 설계(필수 최소 스키마)

### 3.1 Session
- `id`
- `status`: `active | finalizing | finalized`
- `category`: `newbiz | marketing | dev | domain`
- `roundIndex`: 1..3
- `phase`:
  - `A1_PLAN | A2_CRIT_1 | A3_SYN_1 | A2_CRIT_2 | A3_SYN_FINAL | idle | finalizing | finalized`
- `endedReason`: `user_stop | reached_round_limit`
- `createdAt`, `updatedAt`

### 3.2 Messages (채팅 로그)
- `id`, `sessionId`
- `role`: `user | agent1 | agent2 | agent3 | system`
- `roundIndex`
- `phase`
- `content` (채팅 본문)
- `reasoningSummary` (논리 요약 bullets; 렌더용)
- `createdAt`

### 3.3 Memory / CaseFile (누적 요약 메모리)
- `sessionId`
- `facts[]` (확정 사실)
- `goals[]` (KPI/우선순위)
- `constraints[]` (예산/기간/리소스/금지)
- `decisions[]` (합의된 결론)
- `openIssues[]` (미해결 쟁점)
- `assumptions[]` (가정)
- `nextExperiments[]` (검증 실험)
- `updatedAt`

### 3.4 FinalReport (최종 결과물)
- `sessionId`
- `finalMarkdown` 또는 `finalJson`
- `createdAt`

---

## 4) 상태 머신(라운드/턴 강제 로직)

### 4.1 라운드 진행 규칙
- 사용자 입력이 들어오면:
  - `stopIntent` 체크(조기 종료 의도)
  - stop이 아니면 “현재 라운드 진행” 또는 “다음 라운드 시작” 판단

### 4.2 내부 턴 전이(고정)
- `A1_PLAN` → `A2_CRIT_1` → `A3_SYN_1` → `A2_CRIT_2` → `A3_SYN_FINAL` → `idle`

### 4.3 3회 제한(라운드 제한)
- `roundIndex < 3`:
  - 라운드 종료 후 사용자 추가 입력 시 `roundIndex++` 후 다시 `A1_PLAN` 시작
- `roundIndex == 3`:
  - 라운드 종료 시 자동으로 `finalizing` 진행(Agent3 Finalizer 호출) 후 `/final` 이동

### 4.4 조기 종료
- 사용자 stop 트리거 감지 또는 버튼 클릭:
  - 현재 스트리밍/턴 취소
  - `status=finalizing`
  - Agent3 Finalizer 호출
  - `status=finalized` 후 `/final` 라우팅

---

## 5) “논리/추론 요약” 노출을 위한 출력 포맷(강제)

### 5.1 모든 에이전트 공통 출력 구조(채팅 렌더용)
- `결론`: 1~2문장
- `논리 요약`: 3~6 bullets (근거/판단기준/제약 반영)
- `가정/제약`: 있으면 bullets
- `다음 액션`: 체크리스트

> 구현 팁: 에이전트 출력은 JSON으로 받되, UI에서는 카드로 렌더  
> - `content` = 결론+본문  
> - `reasoningSummary` = bullets만 별도 필드로 저장/표시

### 5.2 Agent별 역할 고정
- Agent1(실행계획):
  - MVP 범위/일정/리소스/측정(KPI) 반드시 포함
- Agent2(반박):
  - 치명 리스크 Top 3 + 실패 시나리오 + 검증 실험 2개(필수)
- Agent3(절충):
  - “수용/보류/반박” 분류표 + 개선된 실행안 + Plan B + 2주 검증 플랜

---

## 6) 프롬프트 설계(안티그래비티 내 3 에이전트 템플릿)

### 6.1 공통 인풋(매 호출에 포함)
- `Category` (4종 중 1)
- `Topic` (사용자 주제)
- `CaseFile` (facts/goals/constraints/decisions/openIssues/assumptions)
- `RecentMessages` (최근 N개 메시지 요약 + 직전 상대 발언 핵심)

### 6.2 Agent1 시스템 지시(요지)
- “구체적 실행계획/구현방안 중심”
- 출력은 지정 포맷(JSON) 준수
- 카테고리별 루브릭을 적용(아래 7장)

### 6.3 Agent2 시스템 지시(요지)
- “리스크 오피서/반대 심사역”
- 허점/누락/병목/측정 불가능을 공격
- 반드시 ‘반증 실험/확인 질문’을 제시

### 6.4 Agent3 시스템 지시(요지)
- “합의안 설계자”
- Agent2의 지적을 수용/보류/반박으로 처리하고 개선안 제시
- 최종안은 실행 체크리스트와 로드맵 형태로 확정

---

## 7) 카테고리별 루브릭(토론 논쟁 최소화용)

### 7.1 신규사업
- 가치제안(1문장) / 타깃 / 대안(경쟁) / 수익모델 / 단위경제(대략) / 실행리스크 / 2주 검증 실험

### 7.2 마케팅
- 퍼널 단계 / KPI(CAC/CPA/전환율) / 채널 전략 / 메시지·크리에이티브 / 측정(어트리뷰션) / 운영 리소스

### 7.3 개발
- MVP 범위 / 아키텍처 / 데이터 모델 / API/권한 / 일정·리스크 / 테스트·관측(로그/모니터링) / 롤백

### 7.4 영역(운영/기타)
- 프로세스 / 정책·권한 / SLA / 비용 / 리스크(법무/보안/품질) / 운영지표 / 자동화 여지

---

## 8) 메모리(지속 대화) 설계: “종료 전까지 이전 대화 기반 유지”

### 8.1 저장은 전체 로그 + 요약 메모리(CaseFile)
- 모든 메시지는 `messages`에 저장
- LLM 호출 시 “전체 로그”를 넣지 않고:
  - `CaseFile + 최근 N턴 + 필요한 과거 요약 스니펫`만 전달

### 8.2 CaseFile 업데이트 규칙(라운드 종료 시)
- Agent3 `A3_SYN_FINAL` 이후:
  - `decisions` 갱신(이번 라운드 결론)
  - `openIssues` 갱신(남은 쟁점)
  - `assumptions` 정리(불확실 요소)
  - `nextExperiments` 갱신(검증 플랜)
- 이 업데이트는 오케스트레이터가 수행(에이전트에게 “요약만” 시켜도 됨)

---

## 9) 스트리밍/이벤트로 3D 캐릭터 연출 연결

### 9.1 이벤트 타입(권장)
- `speaker_change`: `{activeSpeaker: agent1|agent2|agent3|none}`
- `message_stream_start`: `{role, phase}`
- `message_stream_chunk`: `{text}`
- `message_stream_end`: `{messageId}`
- `finalize_start`, `finalize_done`

### 9.2 3D 연출 규칙
- `speaker_change` 수신 시:
  - 해당 캐릭터: `speaking` 애니메이션
  - 나머지: `idle`
  - 시각적 강조(빛/외곽선/카메라 줌) 적용

---

## 10) 3D 구현 옵션 (AntiGravity 환경 기준 권장)

### 10.1 MVP(가장 빠른 방식)
- 3D 씬을 Spline 등에서 제작 → AntiGravity에 임베드(또는 WebGL 컴포넌트)
- speaking 상태는 “하이라이트/줌/표정 전환” 정도로 단순화

### 10.2 본격(품질형)
- Three.js / react-three-fiber 기반
- 캐릭터 GLB 3개(Idle/Speaking 애니메이션 클립 포함)
- 상태 전환만 이벤트로 제어

> 준비물(아트 에셋)
- 캐릭터 3명 GLB
- 애니메이션 클립: idle, speak (최소 2개)
- 조명/배경(가벼운 씬) + 성능 최적화(폴리곤/텍스처 압축)

---

## 11) 최종 결과 페이지(`/final`) 출력 포맷(고정)

최종 페이지 섹션(권장):
1) 최종 결론(요약 5~8줄)
2) 채택된 방향(Top 5)
3) 실행 로드맵(주차/단계)
4) 리스크 및 대응(Top 5)
5) KPI/측정(판정 기준 포함)
6) 오픈 이슈(추가 확인)
7) 부록: 라운드별 결정 요약(선택)

최종안 생성 주체:
- **Agent3 Finalizer**(별도 모드)
- 입력: `CaseFile + 마지막 라운드 핵심 요약`
- 출력: `finalJson` 또는 `finalMarkdown`

---

## 12) 구현 단계(권장 작업 순서)

### Phase 1: 토론 엔진 MVP(기능 우선)
1) 세션/메시지/케이스파일 스키마 구성
2) 오케스트레이터 상태 머신 구현(5턴 고정, 3라운드 제한)
3) 에이전트 3종 프롬프트 + JSON 출력 강제
4) 채팅 UI(우측) 스트리밍 렌더 + 배지/라운드 표시
5) 조기 종료 버튼 + stop 트리거(텍스트) 구현
6) Agent3 Finalizer + `/final` 페이지 연결

### Phase 2: 3D 씬 연동(연출)
1) 좌측 `ScenePanel` 추가(임베드 또는 WebGL)
2) `speaker_change` 이벤트로 speaking/idle 전환
3) 발화 중 강조 연출(하이라이트/줌)

### Phase 3: 품질/운영
1) CaseFile 자동 업데이트(라운드 종료 후 정리)
2) 재접속/새로고침 시 세션 복구
3) 로그/오류 처리(중단/재시도 정책)
4) 최종 리포트 템플릿 정교화(카테고리별 섹션 가중)

---

## 13) 품질 기준(완료 판정)

- 사용자가 주제 입력 시, 항상 A1→A2→A3→A2→A3 순서로 채팅이 출력된다.
- 각 메시지에 “논리 요약” 섹션이 반드시 포함된다.
- 라운드가 최대 3회까지만 진행되며, 3회 완료 시 자동으로 `/final`로 이동한다.
- 사용자가 중간에 “마무리”를 선언하면 즉시 중단하고 Agent3 최종안을 생성하여 `/final`로 이동한다.
- 좌측 3D 캐릭터는 activeSpeaker에 맞춰 speaking/idle이 시각적으로 구분된다.
- 종료 전까지 대화가 지속되며(세션 active), CaseFile 기반으로 이전 대화 맥락이 유지된다.

---

## 14) 산출물 목록(개발 완료 시)

- 토론 화면(`/session/:id`)
  - 좌측 3D 캐릭터 패널 + 우측 채팅 패널
- 최종 결과 페이지(`/session/:id/final`)
  - 최종 결론 문서 형태 렌더
- 오케스트레이터(상태 머신/조기 종료/3라운드 제한)
- 에이전트 프롬프트 3종 + Finalizer 1종
- DB 스키마(Session/Messages/CaseFile/FinalReport)
- 운영 로그(토론 트랜스크립트/결정 요약)

---
