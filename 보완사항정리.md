# 필수/권장 보완사항 정리 (v1.1) — AntiGravity 토론 시스템

본 문서는 현재 최종 구현 계획안에서 **반드시 보완해야 할 핵심(버그/설계 누락)**, **강력 권장(운영 안정성)**, **있으면 좋은 보완(확장성)** 항목을 요약 정리합니다.

---

## 1) 반드시 보완해야 할 핵심(버그/설계 누락)

### A. 라운드 증가 로직 누락(치명)
- 현 상태에서 `SessionState.advance()`는 **phase 전이만 수행**하고,
  라운드 종료(`IDLE`) 시 **`round_index` 증가가 없음**.
- 이대로면 “총 3회” 제한 및 라운드 진행이 정상 동작하지 않을 가능성이 큼.

#### 권장 수정안(택1)
**안 1(권장): “새 라운드 시작 시” 증가**
- `IDLE` 상태에서 **사용자 메시지 수신 시**
  - `round_index += 1`
  - 이후 `A1_PLAN` 진입

**안 2: “라운드 종료 시점” 증가**
- `A3_SYN_FINAL → IDLE` 전이 직후
  - `round_index += 1`
- 단, “3라운드 종료 판정”의 기준(증가 전/후)을 명확히 고정해야 함.

#### 추가 점검
- `can_start_new_round()`가 `round_index < max_rounds` 조건이라면,
  라운드 증가 시점에 따라 **`<` vs `<=`** 조건이 달라질 수 있으므로 함께 재점검 필요.

---

### B. 스트리밍 응답과 JSON 스키마 강제를 동시에 사용 시 파손 가능
- 스트리밍(`send_message_stream`) + 구조화 출력(`response_mime_type=application/json`, `response_schema`)을 동시에 쓰면,
  스트리밍 중 JSON이 조각으로 도착해 **항상 파싱 가능한 완전 JSON 보장 어려움**.

#### 권장 해결(가장 안정적인 실무 방식: 2-step)
- **UI 노출용**: 스트리밍 텍스트(사람이 읽는 메시지)
- **저장/렌더/후처리용**: 턴 종료 후 Non-stream 1회 호출로 JSON 생성  
  (또는 스트림을 서버에서 버퍼링 후 완성본만 파싱)

> 결론: 1턴당 “표시용 스트림”과 “구조화 결과(JSON)”를 분리하면 안정성이 크게 개선됨.

---

### C. 조기 종료를 정규식 감지에만 의존하면 오탐 위험
- `STOP_TRIGGERS`에 “정리해줘”, “최종안” 등이 포함되면,
  사용자가 단순 요약을 요청한 것인데 세션이 종료될 수 있음.

#### 권장 보완
- UI 버튼 **`마무리하기`**를 “정식 종료 채널”로 우선 적용
- 텍스트 종료는 아래 중 하나로 안정화:
  - (가장 안전) `/stop`, `/final` 같은 **명령어 프리픽스**
  - 또는 stop 감지 시 **종료 의도 확인(모달/토스트) 1회** 제공

---

## 2) 강력 권장(품질/운영 안정성)

### D. 동시성 제어(턴 중복 실행 방지) + 취소(Abort) 설계 필요
SSE 재연결 및 사용자 연속 입력 상황에서 다음 문제가 발생 가능:
- 같은 세션에서 **턴 중복 실행**
- 최종화 중에 **추가 메시지 유입(레이스 컨디션)**

#### 필수 장치
- **세션 단위 락(lock) / 큐(queue)**: `session_id`별 “동시에 1턴만 실행”
- **취소 토큰(Abort)**:
  - 조기 종료 시 진행 중 LLM 호출 취소(가능한 범위)
  - 최소한 서버는 이후 chunk 송출 중단
- 서버는 `status=finalizing` 시 **추가 메시지 거부**  
  (또는 “다음 세션 시작”으로 분기)

---

### E. SSE 재연결 시 이벤트 유실/중복 처리(Last-Event-ID) 권장
- 단순 재연결(예: 3초 후 재연결)만으로는 운영 환경에서 **chunk 유실**이 발생할 수 있음.

#### 권장 설계
- 모든 이벤트에 `event_id`(단조 증가) 부여
- 클라이언트가 `Last-Event-ID`를 서버로 전달
- 서버는 미수신 이벤트 재전송 가능하게 구현  
  (최소 구현: “턴 종료 메시지” 수준만이라도 재전송)

---

### F. CaseFile(누적 메모리) 업데이트 단위를 명확화
- CaseFile 모델은 있어도, 아래가 구현 레벨로 명확하지 않으면 품질이 흔들림:
  - 언제/어떤 규칙으로 업데이트하는지
  - LLM이 업데이트하는지 / 서버가 규칙으로 업데이트하는지

#### 권장 운영 규칙(서버 주도)
- 라운드 종료 시점(= `A3_SYN_FINAL` 후) **서버가 CaseFile 갱신**
- 최소 강제 필드 4종:
  - `decisions`, `openIssues`, `assumptions`, `nextExperiments`
- CaseFile 요약 길이 제한(권장): **800~1200자**
  - 다음 라운드 프롬프트 및 최종안 생성의 핵심 입력으로 사용

---

## 3) 있으면 좋은 보완(완성도/확장성)

### G. 모델/API 변경 대비 + 의존성 핀닝
- 모델명을 환경변수로 관리하는 방향은 적절함.
- 운영 안정성을 위해 추가 권장:
  - `google-generativeai` 버전 핀닝(예: `==x.y.z`) 또는 최소 호환 범위 명시
  - 모델 호출 래퍼(Adapter) 도입: `GeminiClientAdapter` 등  
    → API 변경 충격을 최소화

---

### H. Finalizer는 “프롬프트”뿐 아니라 “출력 스키마”도 고정 권장
- 최종 페이지는 렌더링 목적이므로:
  - 최종 결과물은 Markdown보다 **JSON(섹션별 필드 구조)**를 우선 권장
  - UI는 JSON 렌더 → 필요 시 Markdown export 제공

---

## 결론: 운영 안정성을 크게 올리는 우선순위 체크리스트(Top 6)
1. 라운드 증가/판정 로직 수정(advance만으로 부족)  
2. 스트리밍 표시와 JSON 구조화 저장 분리(2-step 권장)  
3. 조기 종료 오탐 방지(버튼 우선, 텍스트는 명령어 또는 1회 확인)  
4. 세션 단위 락/큐 + 취소 토큰(중복 턴/레이스 방지)  
5. SSE 이벤트 유실/중복 방지(event_id, Last-Event-ID)  
6. 라운드 종료 시 CaseFile 업데이트 규칙을 서버 단에서 확정(길이 제한 포함)

---
